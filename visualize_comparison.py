import os
import argparse
import pyvista as pv
import numpy as np
import h5py

def get_topology_from_h5(h5_path):
    """Loads the tetrahedral topology from an H5 file."""
    with h5py.File(h5_path, 'r') as f:
        topology = f['topology'][:]
    
    # Handle both raw and VTK-style topology arrays
    if topology.ndim == 1 and topology.size % 5 == 0:
        num_tetra = topology.size // 5
        cells = topology.reshape((num_tetra, 5))
    else: # Assume raw (N, 4) topology
        num_tetra = topology.shape[0]
        cells = np.full((num_tetra, 5), 4, dtype=topology.dtype)
        cells[:, 1:] = topology
        
    cells = cells.flatten()
    cell_types = np.full(num_tetra, pv.CellType.TETRA, dtype=np.uint8)
    return cells, cell_types

def create_mesh_from_data(points, h5_path):
    """Creates a PyVista UnstructuredGrid object from node coordinates and a topology file."""
    cells, cell_types = get_topology_from_h5(h5_path)
    return pv.UnstructuredGrid(cells, cell_types, points)

def visualize_comparison(file_paths, model_names, output_filename="comparison.png"):
    """
    Generates a side-by-side visualization of multiple model predictions against the ground truth.
    
    Args:
        file_paths (list): A list of paths to the .npz files generated by evaluate_model.py.
        model_names (list): A list of names for the models, corresponding to the file_paths.
        output_filename (str): Name of the file to save the plot.
    """
    if len(file_paths) != len(model_names):
        raise ValueError("The number of file paths must match the number of model names.")

    # --- 1. Load all data ---
    all_data = [np.load(fp) for fp in file_paths]

    # Ground truth and coordinates should be the same for all files, so load from the first one.
    gt_displacement = all_data[0]['ground_truth']
    node_coords = all_data[0]['node_coordinates']
    original_h5_path = str(all_data[0]['original_h5_path'])

    predictions = [data['prediction'] for data in all_data]

    # --- 2. Create PyVista Meshes ---
    # Create the base mesh from the original node coordinates
    base_mesh = create_mesh_from_data(node_coords, original_h5_path)

    # Create meshes for ground truth and each prediction
    gt_mesh = base_mesh.copy()
    gt_mesh.point_data['displacement'] = gt_displacement
    gt_mesh.point_data['magnitude'] = np.linalg.norm(gt_displacement, axis=1)

    pred_meshes = []
    for pred in predictions:
        mesh = base_mesh.copy()
        mesh.point_data['displacement'] = pred
        mesh.point_data['magnitude'] = np.linalg.norm(pred, axis=1)
        pred_meshes.append(mesh)
        
    # --- 3. Calculate Error Fields ---
    error_meshes = []
    for pred in predictions:
        mesh = base_mesh.copy()
        error = np.linalg.norm(pred - gt_displacement, axis=1)
        mesh.point_data['error'] = error
        error_meshes.append(mesh)
        
    # Find a global min/max for the error colormap for fair comparison
    max_error = max(em.point_data['error'].max() for em in error_meshes)
    error_clim = [0, max_error]

    # --- 4. Plotting ---
    num_models = len(model_names)
    num_cols = 1 + num_models + num_models # GT + N_preds + N_errors
    plotter = pv.Plotter(shape=(1, num_cols), window_size=[400 * num_cols, 600], off_screen=True)

    # Plot Ground Truth
    plotter.subplot(0, 0)
    plotter.add_text("Ground Truth", font_size=12)
    plotter.add_mesh(gt_mesh, scalars='magnitude', cmap='viridis', show_edges=False)

    # Plot Predictions and Errors
    for i in range(num_models):
        # Prediction
        plotter.subplot(0, 1 + i)
        plotter.add_text(f"{model_names[i]} Prediction", font_size=12)
        plotter.add_mesh(pred_meshes[i], scalars='magnitude', cmap='viridis', show_edges=False)
        
        # Error
        plotter.subplot(0, 1 + num_models + i)
        plotter.add_text(f"{model_names[i]} Error", font_size=12)
        sargs = dict(title='Abs. Error (m)')
        plotter.add_mesh(error_meshes[i], scalars='error', cmap='Reds', show_edges=False, clim=error_clim, scalar_bar_args=sargs)

    plotter.link_views()
    plotter.view_isometric()
    
    print(f"Saving comparison plot to {output_filename}...")
    plotter.screenshot(output_filename)
    print("Done.")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Visualize and compare model predictions.")
    parser.add_argument('--files', nargs='+', required=True, help="List of .npz prediction files.")
    parser.add_argument('--names', nargs='+', required=True, help="List of model names for plot titles.")
    parser.add_argument('--output', type=str, default="comparison_plot.png", help="Output image file name.")
    
    args = parser.parse_args()
    
    visualize_comparison(args.files, args.names, args.output)

